<HTML>
    <head>
        <script src="lib/flocking/dist/flocking-all.js"></script>
        <script src="lib/artlib/adam.js"></script>
        <script>
            flock.init({
                //chans:4, 
                bufferSize: 256 // lowest that chrome allows
            });
            var as = flock.environment.audioSystem;
        </script>
    </head>
    <body>


    <script>
        var quneo = flock.midi.connection({
            openImmediately: true,
            ports: {
                input: {
                    name: "Quneo"
                },
                output: {
                    name: "Quneo"
                }
            },
            invokers: {
                writePad: {
                    func: function( that, x = 0, y = 0, colour = 1){
                         var midimessage = {type: "noteOn", channel: 0, note: 2, velocity: colour}
                         //that.send({type: "noteOn", note: 3, velocity: 100, channel: 1})
                         //midimessage.note = ( x * 8 ) + y + 36;
                         that.send(midimessage); // set up buttons
                    },
                    args: ["{that}", "{arguments}.0"]
                }
            },
            listeners: {
                onCreate: function(){console.log("fkljasldfj");},
                noteOn: function(msg){console.log(msg)},
                noteOff: function(msg){console.log(msg)},
            }
        });

        var pushcontroller = flock.midi.connection({
            openImmediately: true,
             sysex: true,
             ports: {
                 input: {
                     name:"Ableton Push User Port" 
                 },
                 output: {
                     name: "Ableton Push User Port" 
                 }
             }, 
             notedown: undefined, 
             invokers: {
                 writePad: {
                     func: function(that, x = 0, y = 0, colour = 1){
                         var midimessage = {type: "noteOn", channel: 0, note: 36, velocity: colour}
                         midimessage.note = ( x * 8 ) + y + 36;
                         that.send(midimessage); // set up buttons
                     },
                     args: ["{that}", "{arguments}.0", "{arguments}.1", "{arguments}.2"]
                 },
             },
             listeners: {
                 onReady: {
                     func: function(that){
                         for(var x = 0; x < 8; x++){
                             for( var y = 0; y < 8; y++){
                                 that.writePad(x,y,0);
                             }
                         }
                         that.send({type: "control", number: 85, value: 1, channel: 0}); // play button
                         that.send({type: "control", number: 87, value: 1, channel: 0}); // new button
                         that.send({type: "control", number: 40, value: 1, channel: 0}); // 1/16 button
                         that.send({type: "control", number: 20, value: 10, channel: 0}); //  top strip
                         that.send({type: "control", number: 21, value: 1, channel: 0}); //  top strip
                         that.send({type: "control", number: 102, value: 1, channel: 0}); // bottom strip
                     },
                     args: ["{that}"]
                 },
                 noteOff: {
                     func: function(that, msg){
                         if (msg.note < 30){return;}; // push knob touches send noteon and off
                         if (msg.note === that.options.notedown){
                             var pos = pushNotesToGrid(msg);
                             that.writePad( pos.row, pos.column  );
                             var payload = {"func": "trig", "args": 200};
                             var s = adam.sequence();
                             s.model.loop = true;
                             s.settarget(selectedsynth());
                             s.arraytosequence([payload]); 
                             a.addsequence(s);
                             console.log("single");
                         }
                         that.options.notedown = undefined;
                     },
                     args: ["{that}", "{arguments}.0"]
                 },
                 noteOn: {
                     func: function(that, msg){
                         if (msg.note < 30){return;}; // push knob touches send noteon and off

                         // todo : check to see if grid space is occupied

                         // create sequence!
                         if (that.options.notedown !== undefined && that.options.notedown !== msg.note){
                             // todo: figure out orientation 

                             var startpoint, endpoint; 
                             if (msg.note < that.options.notedown){
                                startpoint = pushNotesToGrid (msg);
                                endpoint = pushNotesToGrid (that.options.notedown);
                             }else{
                                endpoint = pushNotesToGrid (msg);
                                startpoint = pushNotesToGrid (that.options.notedown);
                             };


                             // todo: add multirow sequence
                             var payload = {"func": "trig", "args": 1000};
                             var stepz = [];
                             for (var i = 0; i <= (endpoint.column - startpoint.column); i++){
                                 stepz.push(payload);
                                 that.writePad(startpoint.row, startpoint.column + i);
                             }
                             // ??
                             //var s = adam.sequence({loop: true, target: synth, steps: stepz});
                             var s = adam.sequence();
                             s.model.loop = true;
                             s.settarget(selectedsynth());
                             s.arraytosequence(stepz);
                             a.addsequence(s);

                             //console.log(stepz);
                             that.options.notedown = undefined;
                         }else{
                             that.options.notedown = msg.note;
                         };
                     },
                     args: ["{that}", "{arguments}.0"]
                 },
                 control: {
                     func: function(that, msg){
                         console.log(msg);
                         if(msg.number === 85 && msg.value === 127){
                             a.play();
                         }
                         // change selected synth 
                         if(msg.number === 20 ){
                             selectedsynth = adam.sawsynth;
                             that.send({type: "control", number: 20, value: 10, channel: 0}); //  top strip
                             that.send({type: "control", number: 21, value: 1, channel: 0}); //  top strip
                         }
                         if(msg.number === 21 ){
                             selectedsynth = adam.ticksynth;
                             that.send({type: "control", number: 20, value: 1, channel: 0}); //  top strip
                             that.send({type: "control", number: 21, value: 10, channel: 0}); //  top strip
                         }

                         if(msg.number >= 102 && msg.number <= 109){
                             // change selected payload
                         }
                     },
                     args: ["{that}", "{arguments}.0"]
                 }
             }
        });

        function pushNotesToGrid(msg){
            var notenumber; 
            if (typeof msg === "number")
                notenumber = msg;
            else
                notenumber = msg.note;

            return ({ 
                row: Math.floor((notenumber - 36) / 8),
                column: (notenumber-36) % 8 
            });
        };
    </script>

    <script>
        fluid.defaults( "adam.gridquencer", {
            gradeNames: "fluid.modelComponent",
            model :{}, // put a grid in here? put outputs in here? put inputs in here? 
            invokers: {
                addsequence: {
                    func: function(that, changespec, payloads){
                        // test payloads for object or array
                    
                    },
                    args: ["{that}", "{arguments}.0"]
                },
            }
        });

        fluid.defaults( "adam.gridsynth", {
            gradeNames: "fluid.modelComponent",
            model : {
                synth: null,
                payloads:  [] // available payloads per step
            }
        });

    </script>


    <script>
        fluid.defaults("adam.ticksynth", {
            gradeNames: "flock.synth",
            synthDef: {
                id: "osc",
                ugen: "flock.ugen.impulse",
                freq: {
                    ugen: "flock.ugen.xLine",
                    start: 0,
                    end: 0,
                    duration: 1
                }, // mul: 0.5
            },
            invokers: {
                trig: {
                    func: function(that){
                        that.set({"osc.freq.start": 1000, "osc.freq.end": 0});
                    },
                    args: ["{that}"]
                }
            }
        });

        fluid.defaults("adam.sawsynth", {
            gradeNames: "flock.synth",
            synthDef:{
                id: "osc",
                ugen: "flock.ugen.sawOsc",
                freq: 1000,
                mul: {
                    ugen: "flock.ugen.asr",
                    id: "env",
                    attack: 0.01,
                    sustain: 0.5,
                    release: 0.1
                }
            },
            invokers: {
                trig: {
                    func: function(that, freq){
                        that.set("osc.freq", freq);
                        that.set("env.gate", 1);
                        setTimeout(function(){that.set("env.gate", 0)}, 10);
                    },
                    args: ["{that}", "{arguments}.0"]
                }
            }
        });

        fluid.defaults("adam.grid", {
            gradeNames: "fluid.modelComponent",
            model: {
                rows: 8,
                columns: 8,
                grid: [] // 0-64
            },
            listeners: {
                onCreate: {
                    func: function(that){
                        for (var i = 0; i < (that.model.rows * that.model.columns); i++){
                            that.model.grid[i] = 0;
                        }
                    },
                    args: ["{that}"]
                }
            }
        });

        fluid.defaults("adam.pushsequencelights",{
            gradeNames: "fluid.modelComponent", 
            model: {
                pads: [],
                backgroundColour: 10,
                foregroundColor: 60
            },
        });

        fluid.defaults("adam.sequence", {
            gradeNames: "fluid.modelComponent",
            model: {
                steps: {},
                target: null, // bad practice?
                mute: false,
                loop: false,
                reverse: false, // 
                sync: "temp", // should a sequence start immediately or have a way of getting into sync?
                // steps are either change appliers for synth.set
                // or json {"func":"name", "args",[]} invoking the target
            },
            invokers: {
                settarget: {
                    func: function(that, target){
                        that.model.target = target;
                    },
                    args: ["{that}", "{arguments}.0"]
                },
                setstep: {
                    func: function(that, step, payload){ // number of step, json object
                        that.model.steps[step] = payload;
                    },
                    args: ["{that}", "{arguments}.0", "{arguments}.1"]
                },
                setsequence: {
                    func: function(that, seq){
                        that.model.steps = seq;
                    },
                    args: ["{that}" ,"{arguments}.0"]
                },
                arraytosequence: {
                    func: function(that, arr){
                        // check if arr if undefined? 
                        // check ticks in a beat? 
                        const steplength = Math.floor(480 / arr.length);
                        for(var i = 0; i < arr.length; i++){
                            that.model.steps[steplength * i] = arr[i];
                        }
                    },
                    args: ["{that}", "{arguments}.0"]
                },
                applyoffset: function(){}, // placeholder
                clearsequence: function(){}, // placeholder
            }
        });

        fluid.defaults("adam.sequencer",{
            gradeNames: "flock.synth",
            model: {
                beatlength: 480,
                ticktime: 0,
                sequences: [],
                outputs: [] // graphical, midi, etc...
            },
            synthDef: {
                ugen: "flock.ugen.triggerCallback",
                trigger: {
                    id: "pulse",
                    ugen: "flock.ugen.impulse",
                    freq: 480 // 240 
                },
                options: {
                    callback: {
                        func: function(that){
                            if (that.model.ticktime % that.model.beatlength === 0){
                                console.log("beat");
                            }
                            for (let s of that.model.sequences){
                                var thetick = (s.model.loop === true) ? that.model.ticktime % that.model.beatlength : that.model.ticktime;
                                if ( s.model.steps[thetick] !== undefined){
                                    const payload = s.model.steps[thetick];
                                    const target = s.model.target;
                                    
                                    if(target && target.loop !== false){
                                        if(payload.func){
                                            target[payload.func](payload.args);
                                        }else{
                                            target.set(payload);
                                        }
                                    }
                                }
                            }
                            that.model.ticktime++;
                        },
                        args: ["{that}"]
                    }
                }
            },
            events: {
                thingy: null
            },
            invokers: {
                setbpm: {
                    func: function(that, bpm){
                        that.set("pulse.freq", bpm);
                    },
                    args: ["{that}", "{argumentss}.0"]
                },
                addsequence: {
                    func: function(that, seq){
                        that.model.sequences.push(seq);
                    },
                    args: ["{that}", "{arguments}.0"]
                },
                removesequence: {
                    func: function(that, seq){
                        that.model.sequences.pop();
                    },
                    args: ["{that}", "{arguments}.0"]
                }
            }
        });

        var a = adam.sequencer();
        var selectedsynth = adam.sawsynth; // 
        var selectedpayload = {}; // ??

        /*
           // first demo DEMO
        var payload = {"func": "trig", "args": 1000};
        var s = adam.sequence();
        s.model.loop = true;
        s.settarget(adam.sawsynth());
        s.arraytosequence([payload, payload, payload, payload, payload])

        var t = adam.sequence();
        t.model.loop = true;
        t.settarget(adam.sawsynth());
        /*
        t.setstep(0,{"func": "trig", "args": 600});
        t.setstep(120,{"func": "trig", "args": 600});
        t.setstep(240,{"func": "trig", "args": 600});
        t.setstep(360,{"func": "trig", "args": 600});
        payload2 = { ...payload }; 
        payload2.args = 600;
        t.arraytosequence([payload2, payload2, payload2, payload2])
        //t.arraytosequence([payload2, payload2])

        //a.addsequence(s);
        //a.addsequence(t);
        */

    </script>

    <input type="button" onclick="a.play();">START</input>
    <ul>
        <li><s>single step sequence</s> </li>
        <li> <s>multiple synths availabe on top pads</s></li>
        <li> mute sequence </li>
        <li> reverse sequence </li>
        <li> delete sequence </li>
        <li> check to see if grid placement exists already... </li>
        <li> highlight step</li>
        <li>change sequence length by ammending it </li>
        <li> touch a step to edit its payload?</li>
        <li> offset by touching it (requires mode switching?) </li>
        <li> delete by touching the zone again </li>
        <li> reverse by touching the first (what's the difference of cat to one and reverse?) </li>
        <li> change tempo</li>
        <li> multiple row/beat sequences</li>
        <li> options for step payloads (put them on the next row?)</li>
        <li> cross rhythms, poly temporal (sequencer sends message when a sync occurs?)</li>
        <li> chain sequences </li>
        <li> think through tracks and sequences and instruments </li>
        <li> payloads have functions (random pitch, random pitch from set, non-uniform random pitch set</li>
    </ul>
    </body>
</HTML>
