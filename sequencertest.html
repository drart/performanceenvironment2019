<HTML>
    <head>
        <script src="lib/flocking/dist/flocking-all.js"></script>
        <script src="lib/artlib/adam.js"></script>
        <script>
            flock.init({
                //chans:4, 
                bufferSize: 256 // lowest that chrome allows
            });
            var as = flock.environment.audioSystem;
        </script>
    </head>
    <body>


    <script>
        var pushcontroller = flock.midi.connection({
            openImmediately: true,
             sysex: true,
             ports: {
                 input: {
                     name:"Ableton Push User Port" 
                 },
                 output: {
                     name: "Ableton Push User Port" 
                 }
             }, 
             notedown: undefined, 
             invokers: {
                 writePad: {
                     func: function(that, x = 0, y = 0, colour = 1){
                         var midimessage = {type: "noteOn", channel: 0, note: 36, velocity: colour}
                         midimessage.note = ( x * 8 ) + y + 36;
                         that.send(midimessage); // set up buttons
                     },
                     args: ["{that}", "{arguments}.0", "{arguments}.1", "{arguments}.2"]
                 },
             },
             listeners: {
                 onReady: {
                     func: function(that){
                         for(var x = 0; x < 8; x++){
                             for( var y = 0; y < 8; y++){
                                 that.writePad(x,y,0);
                             }
                         }

                         that.send({type: "control", number: 85, value: 1, channel: 0});
                     },
                     args: ["{that}"]
                 },
                 noteOn: {
                     func: function(that, msg){
                         if (msg.note < 30){return;}; // push knob touches send noteon and off

                         that.options.notedown = msg.note;
                     },
                     args: ["{that}", "{arguments}.0"]
                 },
                 noteOff: {
                     func: function(that, msg){
                         if (msg.note < 30){return;}; // push knob touches send noteon and off
                         if (that.options.notedown !== msg.note){
                             // create sequence!
                             //console.log( pushNotesToGrid(msg));
                             //console.log( pushNotesToGrid(that.options.notedown));
                             // todo: figure out orientation 
                             var startpoint = pushNotesToGrid (msg);
                             var endpoint = pushNotesToGrid (that.options.notedown);
                             console.log(endpoint.column - startpoint.column);


                             // do a single row  sequence for now
                             var payload = {"func": "trig", "args": 1000};
                             var stepz = [];
                             for (var i = 0; i <= (endpoint.column - startpoint.column); i++){
                                 stepz.push(payload);
                                 that.writePad(startpoint.row, startpoint.column + i);
                             }
                             console.log(stepz);
                             // ??
                             //var s = adam.sequence({loop: true, target: synth, steps: stepz});
                             var s = adam.sequence();
                             s.model.loop = true;
                             s.settarget(adam.sawsynth());
                             s.arraytosequence(stepz);
                             a.addsequence(s);
                         }else{
                             console.log(pushNotesToGrid(msg));
                            
                             var pos = pushNotesToGrid(msg);
                             that.writePad( pos.row, pos.column  );
                             var payload = {"func": "trig", "args": 200};
                             var s = adam.sequence();
                             s.model.loop = true;
                             s.settarget(adam.sawsynth());
                             s.arraytosequence([payload]); 
                             a.addsequence(s);
                         };
                     },
                     args: ["{that}", "{arguments}.0"]
                 },
                 control: {
                     func: function(that, msg){
                         console.log(msg);
                         if(msg.number === 85 && msg.value === 127){
                             a.play();
                         }
                     },
                     args: ["{that}", "{arguments}.0"]
                 }
             }
        });

        function pushNotesToGrid(msg){
            var notenumber; 
            if (typeof msg === "number")
                notenumber = msg;
            else
                notenumber = msg.note;

            return ({ 
                row: Math.floor((notenumber - 36) / 8),
                column: (notenumber-36) % 8 
            });
        };


    </script>

    <script>
        fluid.defaults( "adam.gridquencer", {
            gradeNames: "fluid.modelComponent",
            model :{} // put a grid in here? put outputs in here? put inputs in here? 
        });
    </script>


    <script>

        fluid.defaults("adam.sawsynth", {
            gradeNames: "flock.synth",
            synthDef:{
                id: "osc",
                ugen: "flock.ugen.sawOsc",
                freq: 1000,
                mul: {
                    ugen: "flock.ugen.asr",
                    id: "env",
                    attack: 0.01,
                    sustain: 0.5,
                    release: 0.1
                }
            },
            invokers: {
                trig: {
                    func: function(that, freq){
                        that.set("osc.freq", freq);
                        that.set("env.gate", 1);
                        setTimeout(function(){that.set("env.gate", 0)}, 10);
                    },
                    args: ["{that}", "{arguments}.0"]
                }
            }
        });

        fluid.defaults("adam.grid", {
            gradeNames: "fluid.modelComponent",
            model: {
                rows: 8,
                columns: 8,
                grid: [] // 0-64
            },
            listeners: {
                onCreate: {
                    func: function(that){
                        for (var i = 0; i < (that.model.rows * that.model.columns); i++){
                            that.model.grid[i] = 0;
                        }
                    },
                    args: ["{that}"]
                }
            }
        });

        fluid.defaults("adam.pushsequencelights",{
            gradeNames: "fluid.modelComponent", 
            model: {
                pads: [],
                backgroundColour: 10,
                foregroundColor: 60
            },
        });

        fluid.defaults("adam.sequence", {
            gradeNames: "fluid.modelComponent",
            model: {
                target: null, // bad practice?
                loop: false,
                sync: "temp", // should a sequence start immediately or have a way of getting into sync?
                // steps are either change appliers for synth.set
                // or json {"func":"name", "args",[]} invoking the target
                steps: {},
                reverse: false, // 
            },
            invokers: {
                //onCreate : console.log("afadfafafadfadfa"), this only fires once? 
                settarget: {
                    func: function(that, target){
                        that.model.target = target;
                    },
                    args: ["{that}", "{arguments}.0"]
                },
                setstep: {
                    func: function(that, step, payload){ // number of step, json object
                        that.model.steps[step] = payload;
                    },
                    args: ["{that}", "{arguments}.0", "{arguments}.1"]
                },
                setsequence: {
                    func: function(that, seq){
                        that.model.steps = seq;
                    },
                    args: ["{that}" ,"{arguments}.0"]
                },
                arraytosequence: {
                    func: function(that, arr){
                        // check if arr if undefined? 
                        // check ticks in a beat? 
                        const steplength = Math.floor(480 / arr.length);
                        for(var i = 0; i < arr.length; i++){
                            that.model.steps[steplength * i] = arr[i];
                        }
                    },
                    args: ["{that}", "{arguments}.0"]
                }
            }
        });

        fluid.defaults("adam.sequencer",{
            gradeNames: "flock.synth",
            model: {
                beatlength: 480,
                ticktime: 0,
                sequences: [],
                outputs: [] // graphical, midi, etc...
            },
            synthDef: {
                ugen: "flock.ugen.triggerCallback",
                trigger: {
                    id: "pulse",
                    ugen: "flock.ugen.impulse",
                    freq: 480 // 240 
                },
                options: {
                    callback: {
                        func: function(that){
                            if (that.model.ticktime % that.model.beatlength === 0){
                                console.log("beat");
                            }
                            for (let s of that.model.sequences){
                                var thetick = (s.model.loop === true) ? that.model.ticktime % that.model.beatlength : that.model.ticktime;
                                if ( s.model.steps[thetick] !== undefined){
                                    const payload = s.model.steps[thetick];
                                    const target = s.model.target;
                                    
                                    if(target){
                                        if(payload.func){
                                            target[payload.func](payload.args);
                                        }else{
                                            target.set(payload);
                                        }
                                    }
                                }
                            }
                            that.model.ticktime++;
                        },
                        args: ["{that}"]
                    }
                }
            },
            events: {
                thingy: null
            },
            invokers: {
                setbpm: {
                    func: function(that, bpm){
                        that.set("pulse.freq", bpm);
                    },
                    args: ["{that}", "{argumentss}.0"]
                },
                addsequence: {
                    func: function(that, seq){
                        that.model.sequences.push(seq);
                    },
                    args: ["{that}", "{arguments}.0"]
                }
            }
        });

        var a = adam.sequencer();

        /*
           // first demo DEMO
        var payload = {"func": "trig", "args": 1000};
        var s = adam.sequence();
        s.model.loop = true;
        s.settarget(adam.sawsynth());
        s.arraytosequence([payload, payload, payload, payload, payload])

        var t = adam.sequence();
        t.model.loop = true;
        t.settarget(adam.sawsynth());
        /*
        t.setstep(0,{"func": "trig", "args": 600});
        t.setstep(120,{"func": "trig", "args": 600});
        t.setstep(240,{"func": "trig", "args": 600});
        t.setstep(360,{"func": "trig", "args": 600});
        payload2 = { ...payload }; 
        payload2.args = 600;
        t.arraytosequence([payload2, payload2, payload2, payload2])
        //t.arraytosequence([payload2, payload2])

        //a.addsequence(s);
        //a.addsequence(t);
        */

    </script>

    <input type="button" onclick="a.play();">START</input>
    <ul>
        <li>check to see if grid placement exists already... </li>
        <li>highlight step</li>
        <li>change sequence length by ammending it </li>
        <li><s>single step sequence</s> </li>
        <li>offset by touching it  </li>
        <li>delete by touching the zone again </li>
        <li>reverse by touching the first (what's the difference of cat to one and reverse?) </li>
        <li> change tempo</li>
        <li> multiple row/beat sequences</li>
        <li> multiple synths availabe on top pads</li>
        <li> options for step payloads (put them on the next row?)</li>
    </ul>
    </body>
</HTML>
