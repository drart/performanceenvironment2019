<HTML>
    <head>
        <script src="../lib/flocking/dist/flocking-all.js"></script>
        <!--script src="../lib/artlib/adam.js"></script-->
        <script>
            flock.init({
                //chans:4, 
                bufferSize: 256 // lowest that chrome allows
            });
            var as = flock.environment.audioSystem;
        </script>
    </head>
    <body>

    <script>
        fluid.defaults( "adam.gridquencer", {
            gradeNames: "adam.sequencer",
            model :{}, 
            subcomponents: {
                grid: "adam.thegrid"
            },
        });

        fluid.defaults( "adam.gridsynth", {
            gradeNames: "fluid.modelComponent",
            model : {
                synth: null,
                payloads:  [] // available payloads per step
            }
        });

    </script>


    <script src="synths.js"></script>
    <script>
        //------------------------------------------
        // grid model
        //------------------------------------------
/*
        fluid.defaults("adam.grid", {
            gradeNames:  "fluid.modelComponent",
            numPads: 64,
            model: {
                pads: "@expand:adam.grid.initEmptyGrid({that}.options.numPads)"
//                 pads: {
//                     "0": true,
//                     "1": false,
//                     "2": true
//                }
            },
            modelListeners: {
                "pads.*": {
                    namespace: "sendMIDIPadState",
                    funcName: "adam.padStateChange", // connect this to adam.push?
                    args: ["{change}.path.0", "{change}.value"]
                }
            }
        });

        adam.grid.initEmptyGrid = function (numPads) {
            var pads = [];
            for (var i = 0; i < numPads; i++) {
                pads[i] = false;
            }
            // return pads;  // ??
        };

        adam.grid.padStateChange = function (padIdx, value) {
            adam.push.sendMidiForStateChange(padIdx, value);
        };

        fluid.defaults("adam.gridzone",{
            gradeNames: "fluid.modelComponent",
            model: {
                gridposition: null,
                activeposition: null,
            },
        });
*/
        fluid.defaults("adam.grid", {
            gradeNames: "fluid.modelComponent",
            model: {
                allowoverflow: false, // zones must be unique
                rows: 8,
                columns: 8,
                grid: [] // 0-64
            },
            modelListeners: {}, //////  THIS!!!!
            invokers: {
                addzone: { 
                    //TODO:  should this function take a zone or should it also define the zone?
                    func: function(that, startpos, endpos ){
                        if (that.model.allowoverflow){
                            // allow all additions to the grid
                            return true;
                        }else{
                            // if region doesn't overlap then add
                            if(endpos !== undefined){
                                return that.checkzoneoverlap(startpos, endpos);
                            }else{
                                return that.checkcelloverlap(startpos);
                            }
                        }
                    },
                    args: ["{that}", "{arguments}.0", "{arguments}.1"]
                },
                addcell: {
                    func: function(that, cell){
                        that.model.grid[cell.row*8 + cell.column] = true;
                    },
                    args: ["{that}", "{arguments}.0"]
                },
                checkzoneoverlap:{ /// TODO 
                    func: function(that, startpos, endpos){
                        for(var r = startpos.row; x < endpos.row+1; r++){
                            for (var c = startpos.column; c < endpos.column+1; c++){
                                if (!that.checkcelloverlap({row:r, column: c})) return false;
                            }
                        }
                        return true;
                    },
                    args: ["{that}", "{arguments}.0", "{arguments}.1"]
                },
                checkcelloverlap: {
                    func: function(that, cell){
                        if( that.model.grid[cell.row*8 + cell.column] !== undefined ){ 
                            return false;
                        }else{
                            return true;
                        }
                    },
                    args: ["{that}", "{arguments}.0"]
                },
                removecell: {
                    func: function(that, cell){
                        that.model.grid[cell.row*8 + cell.column] = undefined;
                    },
                    args: ["{that}", "{arguments}.0"]
                }
            },
            listeners: {
                onCreate: {
                    func: function(that){
                        for (var i = 0; i < (that.model.rows * that.model.columns); i++){
                            that.model.grid[i] = undefined;
                        }
                    },
                    args: ["{that}"]
                }
            }
        });

        fluid.defaults("adam.sequence", {
            gradeNames: "fluid.modelComponent",
            model: {
                beats: 1,
                steps: {},
                target: null, // bad practice?
                mute: false,
                length: null, //
                loop: false,
                reverse: false, // 
                sync: "tempo", // should a sequence start immediately or have a way of getting into sync?
                tickposition: null, // not used yet. useful for retriggering
                // steps are either change appliers for synth.set
                // or json {"func":"name", "args",[]} invoking the target
                playing: false,
                currentstep: undefined,
                previousstep: undefined,
            },
            invokers: {
                settarget: {
                    func: function(that, target){
                        that.model.target = target;
                    },
                    args: ["{that}", "{arguments}.0"]
                },
                setstep: {
                    func: function(that, step, payload){ // number of step, json object
                        that.model.steps[step] = payload;
                    },
                    args: ["{that}", "{arguments}.0", "{arguments}.1"]
                },
                setsequence: {
                    func: function(that, seq){
                        that.model.steps = seq;
                    },
                    args: ["{that}" ,"{arguments}.0"]
                },
                arraytosequence: {
                    func: function(that, arr){
                        if (!Array.isArray(arr)){
                            console.log('warning: arrays must be used for sequences');
                            return -1;
                        }

                        // 480 is divisible by many divisions up to 20 without being too unwielding for the clock
                        const beatlength = 480;  
                        if( Array.isArray(arr[0])){ // multibeat sequence
                            that.model.beats = arr.length;
                            for (var b = 0; b < arr.length; b++){
                                const steplength = Math.floor(beatlength / arr[b].length);
                                for (var i = 0; i < arr[b].length; i++){
                                    //console.log( (steplength *i) + (beatlength * b));
                                    that.model.steps[ (steplength * i) + (beatlength * b) ] = arr[b][i];
                                }
                            }
                        }else{ // single beat sequence
                            const steplength = Math.floor(beatlength / arr.length);
                            for(var i = 0; i < arr.length; i++){
                                that.model.steps[steplength * i] = arr[i];
                            }
                        }
                    },
                    args: ["{that}", "{arguments}.0"]
                },
                retrigger: function(){}, // placeholder
                applyoffset: function(){}, // placeholder
                clearsequence: {
                    func: function(that){
                        that.model.steps = {};
                    },
                    args: "{that}"
                }, 
            }
        });

        fluid.defaults("adam.gridsequence", {
            gradeNames: "adam.sequence",
            model: {
                locations: [] // array matching the length of steps with index, x, y for each step
            },
        });

        fluid.defaults("adam.sequencer",{
            gradeNames: "flock.synth", /// modelComponent?
            model: {
                tempo: 60,
                beatlength: 480,
                ticktime: 0,
                sequences: [],
                selectedsequence: null 
            },
            synthDef: {
                ugen: "flock.ugen.triggerCallback",
                trigger: {
                    id: "pulse",
                    ugen: "flock.ugen.impulse",
                    freq: 480 // 240 
                },
                options: {
                    callback: {
                        func: function(that){
                            if (that.model.ticktime % that.model.beatlength === 0){
                                console.log("beat");
                            }
                            for (let s of that.model.sequences){
                                // TODO should ticktime be kept in the loop instead of the sequencer? 
                                var thetick = (s.model.loop === true) ? that.model.ticktime % (that.model.beatlength * s.model.beats) : that.model.ticktime;
                                if ( s.model.steps[thetick] !== undefined && s.model.mute === false){
                                    const payload = s.model.steps[thetick];
                                    const target = s.model.target;
                                    
                                    if(target && target.loop !== false){
                                        if(payload.location){
                                            //console.log(payload.location);
                                            if (pushr){
                                                pushr.writePad(payload.location.row, payload.location.column, 30) 

                                                if(s.model.previousstep){
                                                    // TODO better reference to the hardware or display level
                                                    pushr.writePad(s.model.previousstep.location.row, s.model.previousstep.location.column);// writes default colour
                                                }
                                            }
                        
                                        };
                                        

                                        if(payload.func){
                                            target[payload.func](payload.args);
                                        }else{
                                            target.set(payload);
                                        }
                                        // todo better solution for single steps so that they still blink on activation? 
                                        if ( Object.keys(s.model.steps).length > 1){
                                            s.model.previousstep = s.model.steps[thetick];
                                        }
                                    }
                                }
                            }
                            that.model.ticktime++;
                        },
                        args: ["{that}"]
                    }
                }
            },
            events: {
                thingy: null
            },
            invokers: {
                setbpm: {
                    func: function(that, bpm){
                        that.model.bpm = bpm;
                        that.set("pulse.freq", that.model.bpm/60);
                    },
                    args: ["{that}", "{argumentss}.0"]
                },
                getsequence: { 
                    func: function(that, seq){
                        let result = that.model.sequences.indexOf(seq);

                        if( result !== -1 ){
                            result = that.model.sequences[ result ]; 
                            return result;
                        }else{
                            return undefined;
                        }
                    },
                    args: ["{that}", "{arguments}.0"]
                },
                addsequence: {
                    func: function(that, seq){
                        seq.model.playing = true; // todo: defer this to actual playing?
                        seq.model.currentstep = 0;
                        that.model.sequences.push(seq);
                    },
                    args: ["{that}", "{arguments}.0"]
                },
                removesequence: {
                    func: function(that, seq){
                        if (seq === undefined){
                            that.model.sequences.pop();
                        }else{
                            that.model.sequences.splice( that.getsequence(seq), 1);
                        }
                    },
                    args: ["{that}", "{arguments}.0"]
                },
                mutesequence: {
                    func: function(that, seq){
                        that.getsequence(seq).mute = true;
                    },
                    args: ["{that}", "{arguments}.0"]
                },
                selectsequence: {
                    func: function(that, seq){
                        if ( that.getsequence(seq) !== -1 ){ 
                            that.model.selectedsequence = seq;
                            return true;
                        }else{
                            return false;
                        }
                    },
                    args: ["{that}", "{arguments}.0"]
                }
            }
        });


        var a = adam.sequencer();
        var selectedsynth = adam.sawsynth; // 
        var selectedpayload = {}; // 
        var selectedsequence = null;

    </script>

    <input type="button" onclick="a.play();">START</input>
    <ul>
        <li><s>single step sequence</s> </li>
        <li> <s>multiple synths availabe on top pads</s></li>
        <li> <s>select sequence </s></li>
        <li> <s>mute sequence</s> </li>
        <li> reverse sequence </li>
        <li> delete sequence </li>
        <li> <s>check to see if grid placement exists already... </s></li>
        <li> <s>highlight step</s></li>
        <li> change sequence length by ammending it </li>
        <li> touch a step to edit its payload?</li>
        <li> offset by touching it (requires mode switching?) </li>
        <li> delete by touching the zone again </li>
        <li> reverse by touching the first (what's the difference of cat to one and reverse?) </li>
        <li> change tempo</li>
        <li> <s>multiple row/beat sequences</s></li>
        <li> options for step payloads (put them on the next row?)</li>
        <li> cross rhythms, poly temporal (sequencer sends message when a sync occurs?)</li>
        <li> chain sequences </li>
        <li> think through tracks and sequences and instruments </li>
        <li> payloads have functions (random pitch, random pitch from set, non-uniform random pitch set</li>
    </ul>

    <script src="enveloper.js"></script>
    <script src="midimappings.js"></script>
    <script>
    </script>
    </body>
</HTML>
