<HTML>
    <head>
        <script src="../lib/flocking/dist/flocking-all.js"></script>
        <!--script src="../lib/artlib/adam.js"></script-->
        <script>
            flock.init({
                //chans:4, 
                bufferSize: 256 // lowest that chrome allows
            });
            var as = flock.environment.audioSystem;
        </script>
    </head>
    <body>


    <script>
        fluid.defaults( "adam.gridquencer", {
            gradeNames: "fluid.modelComponent",
            model :{}, 
            /*
            subcomponents: {
                grid: "adam.thegrid"
            },
            */
            invokers: {
                addsequence: {
                    func: function(that, changespec, payloads){
                        // test payloads for object or array
                    
                    },
                    args: ["{that}", "{arguments}.0"]
                },
            }
        });

        fluid.defaults( "adam.gridsynth", {
            gradeNames: "fluid.modelComponent",
            model : {
                synth: null,
                payloads:  [] // available payloads per step
            }
        });

    </script>


    <script src="synths.js"></script>
    <script>
        //------------------------------------------
        // grid model
        //------------------------------------------
/*
        fluid.defaults("adam.grid", {
            gradeNames:  "fluid.modelComponent",
            numPads: 64,
            model: {
                pads: "@expand:adam.grid.initEmptyGrid({that}.options.numPads)"
//                 pads: {
//                     "0": true,
//                     "1": false,
//                     "2": true
//                }
            },
            modelListeners: {
                "pads.*": {
                    namespace: "sendMIDIPadState",
                    funcName: "adam.padStateChange", // connect this to adam.push?
                    args: ["{change}.path.0", "{change}.value"]
                }
            }
        });

        adam.grid.initEmptyGrid = function (numPads) {
            var pads = [];
            for (var i = 0; i < numPads; i++) {
                pads[i] = false;
            }
            // return pads;  // ??
        };

        adam.grid.padStateChange = function (padIdx, value) {
            adam.push.sendMidiForStateChange(padIdx, value);
        };

        fluid.defaults("adam.gridzone",{
            gradeNames: "fluid.modelComponent",
            model: {
                gridposition: null,
                activeposition: null,
            },
        });
*/
        fluid.defaults("adam.grid", {
            gradeNames: "fluid.modelComponent",
            model: {
                allowoverflow: false, // zones must be unique
                rows: 8,
                columns: 8,
                grid: [] // 0-64
            },
            modelListeners: {}, //////  THIS!!!!
            invokers: {
                addzone: { 
                    //TODO:  should this function take a zone or should it also define the zone?
                    func: function(that, startpos, endpos ){
                        if (that.model.allowoverflow){
                            // allow all additions to the grid
                            return true;
                        }else{
                            // if region doesn't overlap then add
                            if(endpos !== undefined){
                                return that.checkzoneoverlap(startpos, endpos);
                            }else{
                                return that.checkcelloverlap(startpos);
                            }
                        }
                    },
                    args: ["{that}", "{arguments}.0", "{arguments}.1"]
                },
                checkzoneoverlap:{
                    func: function(that, zone){
                        for( cell in zone){
                            if (!that.checkcelloverlap(cell)) return false;
                        }
                        return true;
                    },
                    args: ["{that}", "{arguments}.0"]
                },
                checkcelloverlap: {
                    func: function(that, cell){
                        if( that.model.grid[cell.x*8 + cell.y] !== undefined ){ 
                            return false;
                        }else{
                            return true;
                        }
                    },
                    args: ["{that}", "{arguments}.0", "{arguments}.1"]
                },
            },
            listeners: {
                onCreate: {
                    func: function(that){
                        for (var i = 0; i < (that.model.rows * that.model.columns); i++){
                            that.model.grid[i] = undefined;
                        }
                    },
                    args: ["{that}"]
                }
            }
        });

        //------------------------------------------
        // grid to push mappings
        //------------------------------------------
        fluid.defaults("adam.pushState", {
            gradeNames: "fluid.modelComponent",
            model: {
                mode: "grid", // envelope, sequence, payload
                sequencePads: {
                    "0": {
                        enabled: false,
                        colour: 98
                    }
                },
                samplePads: {
                    "0": {
                        enabled: true
                    }
                }
            },
            modelListeners:{},
            listeners: {
                addsequence: {
                    funcName: "adam.pushState.addsequence",
                    args: ["{that}", "{arguments}.0", "{arguments}.1"]
                } // add sequence to sequencer 
            },
            invokers: {}
        });

        adam.pushState.addsequence = function(that, startpos, endpos){
            adam.grid.addsequence();
        };


        fluid.defaults("adam.sequence", {
            gradeNames: "fluid.modelComponent",
            model: {
                beats: 1,
                steps: {},
                target: null, // bad practice?
                mute: false,
                length: null, //
                loop: false,
                reverse: false, // 
                sync: "tempo", // should a sequence start immediately or have a way of getting into sync?
                tickposition: null, // not used yet. useful for retriggering
                // steps are either change appliers for synth.set
                // or json {"func":"name", "args",[]} invoking the target
            },
            invokers: {
                settarget: {
                    func: function(that, target){
                        that.model.target = target;
                    },
                    args: ["{that}", "{arguments}.0"]
                },
                setstep: {
                    func: function(that, step, payload){ // number of step, json object
                        that.model.steps[step] = payload;
                    },
                    args: ["{that}", "{arguments}.0", "{arguments}.1"]
                },
                setsequence: {
                    func: function(that, seq){
                        that.model.steps = seq;
                    },
                    args: ["{that}" ,"{arguments}.0"]
                },
                arraytosequence: {
                    func: function(that, arr){
                        if (!Array.isArray(arr)){
                            console.log('warning: arrays must be used for sequences');
                            return -1;
                        }

                        // 480 is divisible by many divisions up to 20 without being too unwielding for the clock
                        const beatlength = 480;  
                        if( Array.isArray(arr[0])){ // multibeat sequence
                            that.model.beats = arr.length;
                            for (var b = 0; b < arr.length; b++){
                                const steplength = Math.floor(beatlength / arr[b].length);
                                for (var i = 0; i < arr[b].length; i++){
                                    console.log( (steplength *i) + (beatlength * b));
                                    that.model.steps[ (steplength * i) + (beatlength * b) ] = arr[b][i];
                                }
                            }
                        }else{ // single beat sequence
                            const steplength = Math.floor(beatlength / arr.length);
                            for(var i = 0; i < arr.length; i++){
                                that.model.steps[steplength * i] = arr[i];
                            }
                        }
                    },
                    args: ["{that}", "{arguments}.0"]
                },
                retrigger: function(){}, // placeholder
                applyoffset: function(){}, // placeholder
                clearsequence: {
                    func: function(that){
                        that.model.steps = {};
                    },
                    args: "{that}"
                }, 
            }
        });

        fluid.defaults("adam.gridsequence", {
            gradeNames: "adam.sequence",
            model: {
                locations: [] // array matching the length of steps with index, x, y for each step
            },
        });

        fluid.defaults("adam.sequencer",{
            gradeNames: "flock.synth", /// modelComponent?
            model: {
                tempo: 60,
                beatlength: 480,
                ticktime: 0,
                sequences: [],
                selectedsequence: null 
            },
            synthDef: {
                ugen: "flock.ugen.triggerCallback",
                trigger: {
                    id: "pulse",
                    ugen: "flock.ugen.impulse",
                    freq: 480 // 240 
                },
                options: {
                    callback: {
                        func: function(that){
                            if (that.model.ticktime % that.model.beatlength === 0){
                                console.log("beat");
                            }
                            for (let s of that.model.sequences){
                                var thetick = (s.model.loop === true) ? that.model.ticktime % that.model.beatlength : that.model.ticktime;
                                if ( s.model.steps[thetick] !== undefined){
                                    const payload = s.model.steps[thetick];
                                    const target = s.model.target;
                                    
                                    if(target && target.loop !== false){
                                        if(payload.func){
                                            target[payload.func](payload.args);
                                        }else{
                                            target.set(payload);
                                        }
                                    }
                                }
                            }
                            that.model.ticktime++;
                        },
                        args: ["{that}"]
                    }
                }
            },
            events: {
                thingy: null
            },
            invokers: {
                setbpm: {
                    func: function(that, bpm){
                        that.model.bpm = bpm;
                        that.set("pulse.freq", that.model.bpm/60);
                    },
                    args: ["{that}", "{argumentss}.0"]
                },
                getsequence: {
                    func: function(that, seq){
                        return that.sequences.find( seq );
                    },
                    args: ["{that}", "{arguments}.0"]
                },
                addsequence: {
                    func: function(that, seq){
                        that.model.sequences.push(seq);
                        console.log(that.model.sequences);
                        //that.model.selectedsequence = that.model.sequences[that.model.sequences.length-1]
                    },
                    args: ["{that}", "{arguments}.0"]
                },
                removesequence: {
                    func: function(that, seq){
                        if (seq === undefined){
                            that.model.sequences.pop();
                        }else{
                            that.model.sequences.splice( that.model.sequences.indexOf(seq), 1);
                        }
                    },
                    args: ["{that}", "{arguments}.0"]
                },
                mutesequence: {
                    func: function(that, seq){
                        that.model.sequences.find(seq).mute = true;
                    },
                    args: ["{that}", "{arguments}.0"]
                },
                //// BROKEN
                selectsequence: {
                    func: function(that, seq){
                        console.log(Array.isArray(that.model.sequences));
                        if ( that.model.sequences.find(seq) ){ 
                                that.model.selectedsequence = seq;
                        }
                        //console.log(that.model);
                        //console.log(seq);

                        /*
                        seqprops = Object.getOwnPropertyNames(seq);
                        for (let s of that.model.sequences){
                            let seqproperties = Object.getOwnProperyNames(s);
                            if (seq.length !== seqproperties.length){ continue; }

                            for (var i = 0; i < seqproperties.length; i++ ){
                                var propertyname = seqproperties[i];
                                if (seq[propertyname] !== s[propertyname]) return false;
                            }
                            that.model.selectedsequence = seq;
                            return true;
                        }
                        return false;
                        */
                    },
                    args: ["{that}", "{arguments}.0"]
                }
            }
        });


        var a = adam.sequencer();
        var selectedsynth = adam.sawsynth; // 
        var selectedpayload = {}; // 
        var selectedsequence = null;

    </script>

    <input type="button" onclick="a.play();">START</input>
    <ul>
        <li><s>single step sequence</s> </li>
        <li> <s>multiple synths availabe on top pads</s></li>
        <li> select sequence </li>
        <li> <s>mute sequence</s> </li>
        <li> reverse sequence </li>
        <li> delete sequence </li>
        <li> check to see if grid placement exists already... </li>
        <li> highlight step</li>
        <li> change sequence length by ammending it </li>
        <li> touch a step to edit its payload?</li>
        <li> offset by touching it (requires mode switching?) </li>
        <li> delete by touching the zone again </li>
        <li> reverse by touching the first (what's the difference of cat to one and reverse?) </li>
        <li> change tempo</li>
        <li> <s>multiple row/beat sequences</s></li>
        <li> options for step payloads (put them on the next row?)</li>
        <li> cross rhythms, poly temporal (sequencer sends message when a sync occurs?)</li>
        <li> chain sequences </li>
        <li> think through tracks and sequences and instruments </li>
        <li> payloads have functions (random pitch, random pitch from set, non-uniform random pitch set</li>
    </ul>
    <script>

        /*
           // first demo DEMO
        var payload = {"func": "trig", "args": 1000};
        var s = adam.sequence();
        s.model.loop = true;
        s.settarget(adam.sawsynth());
        s.arraytosequence([payload, payload, payload, payload, payload])

        var t = adam.sequence();
        t.model.loop = true;
        t.settarget(adam.sawsynth());
        /*
        t.setstep(0,{"func": "trig", "args": 600});
        t.setstep(120,{"func": "trig", "args": 600});
        t.setstep(240,{"func": "trig", "args": 600});
        t.setstep(360,{"func": "trig", "args": 600});
        payload2 = { ...payload }; 
        payload2.args = 600;
        t.arraytosequence([payload2, payload2, payload2, payload2])
        //t.arraytosequence([payload2, payload2])

        //a.addsequence(s);
        //a.addsequence(t);
        */
    </script>

    <script src="enveloper.js"></script>
    <script src="midimappings.js"></script>
    <script>
    </script>
    </body>
</HTML>
